# Sort (поиск потока, сортировка потока,преобразование списка в поток)

3 пример

Связывание потоков с базовыми данными, создание потока из List
Как вы думаете, это выводит?
25:   List<String> cats = new ArrayList<>();
26:   cats.add("Annie");
27:   cats.add("Ripley");
28:   Stream<String> stream = cats.stream();
29:   cats.add("KC");
30:   System.out.println(stream.count());
Правильный ответ 3. Строки 25–27 создают Listс двумя элементами. Строка 28 запрашивает создание потока из этого List. 
Помните, что потоки лениво оцениваются. Это означает, что поток на самом деле не создается в строке 28. Создается объект, который знает, 
где искать данные, когда они необходимы. В строке 29, Listполучает новый элемент. На линии 30 потоковый конвейер фактически работает.
Сначала запускается потоковый конвейер, глядя на источник и видя три элемента.

1 пример - сортировка с компоратором и без 
 отсортированный ()
 Сортировать поток. sorted()Метод является промежуточной операцией , которая сортирует поток. Существует две версии: подпись с нулевыми параметрами, 
 которая сортирует с использованием естественного порядка сортировки,
 и подпись с одним параметром, который сортирует с использованием этого Comparatorв качестве порядка сортировки.
 
sorted()Метод возвращает поток с элементами отсортированных. Так же, как сортировка массивов, Java использует естественное упорядочение,
если мы не указываем компаратор. Сигнатуры метода таковы:

Stream<T> sorted()
Stream<T> sorted(Comparator<? super T> comparator)
Вызов первой подписи использует порядок сортировки по умолчанию:

Stream<String> s = Stream.of("brown-", "bear-");
s.sorted().forEach(System.out::print); // bear-brown-
Помните, что мы можем передать лямбда-выражение в качестве компаратора. Например, мы можем передать Comparatorреализацию:

Stream<String> s = Stream.of("brown bear-", "grizzly-");
s.sorted(Comparator.reverseOrder())
  .forEach(System.out::print); // grizzly-brown bear-
Здесь мы передали, Comparatorчтобы указать, что мы хотим отсортировать в обратном порядке естественной сортировки. 

Готовы к хитрому? Вы понимаете, почему это не компилируется?

s.sorted(Comparator::reverseOrder); // DOES NOT COMPILE
Посмотрите на сигнатуры метода еще раз. Comparatorэто функциональный интерфейс Это означает, что мы можем использовать 
ссылки на методы или лямбда-выражения для его реализации. ComparatorИнтерфейс реализует один метод , который принимает два Stringпараметра и возвращает int. 
Однако Comparator::reverseOrderне делает этого. Это ссылка на функцию, которая принимает нулевые параметры и возвращает a Comparator. Это не совместимо с интерфейсом.
Это означает, что мы должны использовать метод, а не ссылку на метод. Мы поднимаем это, чтобы напомнить вам, что вам действительно нужно хорошо знать ссылки на методы. 

2 пример

Собираем трубопровод 
Потоки позволяют вам использовать цепочку и выражать то, что вы хотите достичь, а не как это сделать.
Допустим, мы хотели получить первые два имени в алфавитном порядке длиной четыре символа. 
List<String> list = Arrays.asList("Toby", "Anna", "Leroy", "Alex");
list.stream().filter(n -> n.length() == 4).sorted()
  .limit(2).forEach(System.out::println);
Прежде чем сказать, что его сложнее читать, мы можем отформатировать его:

stream.filter(n -> n.length() == 4)    
  .sorted()    
  .limit(2)   
   .forEach(System.out::println);
Разница в том, что мы выражаем то, что происходит. Мы заботимся об Stringобъектах длины 4. Затем мы хотим их отсортировать. Тогда мы хотим первые два.
Тогда мы хотим распечатать их. 

4 пример
Поиск потока.
findFirst()И findAny()методы возвращают один элемент из потока в Optional. anyMatch(), allMatch()И noneMatch()методы возвращают boolean.
Будьте осторожны, потому что эти три могут зависнуть, если их вызвать в бесконечном потоке с некоторыми данными. 
Все эти методы являются терминальными операциями.
 findAny () и findFirst ()
findAny()И findFirst()методы возвращают элемент потока , если поток не пуст. Если поток пуст, они возвращают пустое Optional.
Это первый метод, который вы видели, который работает с бесконечным потоком. Поскольку Java генерирует только необходимое вам количество потока,
бесконечный поток должен генерировать только один элемент. findAny()полезно, когда вы работаете с параллельным потоком.
Это дает Java возможность гибко возвращать вам первый элемент, а не тот, который должен быть первым в потоке на основе промежуточных операций.
Эти методы являются терминальными операциями, но не сокращениями. Причина в том, что они иногда возвращаются без обработки всех элементов. 
Это означает, что они возвращают значение на основе потока, но не сводят весь поток к одному значению.
Сигнатуры метода таковы:

Optional<T> findAny()
Optional<T> findFirst()

Этот пример находит животное:
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
Stream<String> infinite = Stream.generate(() -> "chimp");
s.findAny().ifPresent(System.out::println); // monkey
infinite.findAny().ifPresent(System.out::println); // chimp

Поиск любого совпадения полезнее, чем кажется. Иногда мы просто хотим проверить результаты и получить репрезентативный элемент, 
но нам не нужно тратить впустую обработку, генерирующую их все. В конце концов, если мы планируем работать только с одним элементом, зачем смотреть дальше? 
 allMatch () , anyMatch () и noneMatch ()
В allMatch(), anyMatch()и noneMatch()методы поиска потока и возврата информации о том , как поток относится к предикату.
Они могут заканчиваться или не заканчиваться для бесконечных потоков. Это зависит от данных. Как и методы поиска, они не являются сокращениями, 
потому что они не обязательно смотрят на все элементы.
Подписи метода следующие:

boolean anyMatch(Predicate <? super T> predicate)
boolean allMatch(Predicate <? super T> predicate)
boolean noneMatch(Predicate <? super T> predicate)

Этот пример проверяет, начинаются ли имена животных с букв:

List<String> list = Arrays.asList("monkey", "2", "chimp");
Stream<String> infinite = Stream.generate(() -> "chimp");
Predicate<String> pred = x -> Character.isLetter(x.charAt(0));
System.out.println(list.stream().anyMatch(pred)); // true
System.out.println(list.stream().allMatch(pred)); // false
System.out.println(list.stream().noneMatch(pred)); // false
System.out.println(infinite.anyMatch(pred)); // true
Это показывает, что мы можем повторно использовать один и тот же предикат, но каждый раз нам нужен другой поток. anyMatch()возвращается,
trueпотому что два из трех элементов совпадают. allMatch()возвращается, falseпотому что один не совпадает. noneMatch()также возвращается,
falseпотому что один соответствует. В бесконечном списке найдено одно совпадение, поэтому вызов завершается. Если мы позвоним noneMatch()или allMatch(),
они будут работать, пока мы не убьём программу.     
Помните , что allMatch(), anyMatch()и noneMatch()возвращать boolean. Методы поиска, напротив, возвращают, Optionalпотому что они возвращают элемент потока.


5 пример
Если в сборщик передать определенную коллекцию она отсортирует в естественном алфавитном порядке
Stream<String> stream = Stream.of("w", "o", "l", "f");
TreeSet<String> set = stream.collect(Collectors.toCollection(TreeSet::new));
System.out.println(set); // [f, l, o, w]
Если бы нам не нужно было сортировать набор, мы могли бы сделать код еще короче:
Stream<String> stream = Stream.of("w", "o", "l", "f");
Set<String> set = stream.collect(Collectors.toSet());
System.out.println(set); // [f, w, l, o]
Вы можете получить другой вывод для этого последнего, так как не toSet()дает никаких гарантий относительно того, какую реализацию Setвы получите.
Это может быть HashSet, но вы не должны ожидать или полагаться на это.  







